#!/usr/bin/env node
// aiAutonomousDevLoop.js
// Autonomous AI development loop for ProtoFusionGirl
// Scans open tasks, selects, implements, tests, and loops with minimal human input

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import axios from 'axios';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ARTIFACTS_DIR = path.join(__dirname, '../artifacts');
const TASK_INDEX = path.join(ARTIFACTS_DIR, 'task_index.artifact');

// CLI argument parsing for codegen mode
// defaults to 'copilot', can be set to 'openai'
const argv = yargs(hideBin(process.argv))
  .option('mode', {
    alias: 'm',
    description: 'Codegen mode: copilot (default) or openai',
    type: 'string',
    default: 'copilot',
    choices: ['copilot', 'openai']
  })
  .help()
  .argv;

console.log(`AI Autonomous Dev Loop running in '${argv.mode}' codegen mode.`);

function getOpenTasks() {
  // Read and parse the task index artifact for open, prioritized tasks (current index format)
  const content = fs.readFileSync(TASK_INDEX, 'utf8');
  const openTasks = [];
  // Example line:
  // - [open] (high) Test Copilot/OpenAI codegen workflow via dev loop (Assignee: copilot) [task_test_codegen_20250604.artifact]
  const taskRegex = /^- \[open\] \(([^)]+)\) (.+?) \(Assignee: ([^)]+)\) \[(task_[^\]]+)\.artifact\]/gm;
  let match;
  while ((match = taskRegex.exec(content))) {
    // Try to get relatedFile from the artifact file for downstream automation
    let relatedFile = '';
    const artifactPath = path.join(ARTIFACTS_DIR, `${match[4]}.artifact`);
    if (fs.existsSync(artifactPath)) {
      const artifactContent = fs.readFileSync(artifactPath, 'utf8');
      const relFileMatch = /relatedFile:\s*['"]?([^\n'"]*)['"]?/i.exec(artifactContent);
      if (relFileMatch && relFileMatch[1]) {
        relatedFile = relFileMatch[1].trim();
      }
    }
    openTasks.push({
      id: match[4],
      status: 'open',
      priority: match[1],
      assignee: match[3],
      purpose: match[2],
      relatedFile
    });
  }
  // Sort by priority (urgent > high > medium > low)
  const priorityOrder = { urgent: 0, high: 1, medium: 2, low: 3 };
  openTasks.sort((a, b) => (priorityOrder[a.priority] ?? 99) - (priorityOrder[b.priority] ?? 99));
  return openTasks;
}

async function implementTask(task) {
  const queueFile = path.join(ARTIFACTS_DIR, 'self_prompt_queue.json');
  let queue = [];
  if (fs.existsSync(queueFile)) {
    try {
      const queueData = JSON.parse(fs.readFileSync(queueFile, 'utf8'));
      // Support both array and {queue: []} formats
      queue = Array.isArray(queueData) ? queueData : (Array.isArray(queueData.queue) ? queueData.queue : []);
    } catch (e) {
      queue = [];
    }
  }

  let codegenSuggestion;
  let codegenOutputFile = path.join(ARTIFACTS_DIR, `codegen_${task.id}_${Date.now()}.txt`);

  if (argv.mode === 'openai') {
    // --- OpenAI codegen integration ---
    const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
    codegenSuggestion = '// [Codegen failed: No API key or error]';
    if (OPENAI_API_KEY) {
      const promptText = `You are an expert game developer AI. Implement the following task for a TypeScript Phaser.js game.\nTask: ${task.purpose}\nContext: ${JSON.stringify(task.context || {}, null, 2)}\nOutput only the code, no explanation.`;
      try {
        const response = await axios.post('https://api.openai.com/v1/chat/completions', {
          model: 'gpt-4',
          messages: [
            { role: 'system', content: 'You are a helpful AI game developer.' },
            { role: 'user', content: promptText }
          ],
          max_tokens: 800
        }, {
          headers: {
            'Authorization': `Bearer ${OPENAI_API_KEY}`,
            'Content-Type': 'application/json'
          }
        });
        const data = response.data;
        codegenSuggestion = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content
          ? data.choices[0].message.content.trim()
          : '// [Codegen: No output]';
      } catch (err) {
        codegenSuggestion = `// [Codegen error: ${err.message}]`;
      }
      fs.writeFileSync(codegenOutputFile, codegenSuggestion, 'utf8');
    } else {
      codegenSuggestion = '// [Codegen skipped: No OPENAI_API_KEY in environment]';
      fs.writeFileSync(codegenOutputFile, codegenSuggestion, 'utf8');
    }
  } else {
    // --- Copilot codegen simulation (default) ---
    codegenSuggestion = `// [Copilot AI Agent codegen placeholder for: ${task.purpose}]\n// This would be generated by GitHub Copilot's AI Agent.`;
    fs.writeFileSync(codegenOutputFile, codegenSuggestion, 'utf8');
  }

  // Add prompt to queue for traceability
  const prompt = {
    taskId: task.id,
    purpose: task.purpose,
    timestamp: new Date().toISOString(),
    context: task.context || {},
    prompt: `Implement the following task: ${task.purpose}`,
    codegenOutputFile
  };
  queue.push(prompt);
  // When saving, preserve {queue: []} format if present
  let queueToWrite = {};
  if (fs.existsSync(queueFile)) {
    try {
      const queueData = JSON.parse(fs.readFileSync(queueFile, 'utf8'));
      if (queueData && typeof queueData === 'object' && Array.isArray(queueData.queue)) {
        queueToWrite = { ...queueData, queue };
      } else {
        queueToWrite = queue;
      }
    } catch {
      queueToWrite = queue;
    }
  } else {
    queueToWrite = queue;
  }
  fs.writeFileSync(queueFile, JSON.stringify(queueToWrite, null, 2), 'utf8');
  console.log(`Prompt for task ${task.id} added to self_prompt_queue.json.`);
  console.log(`Codegen output written to ${codegenOutputFile}`);

  // --- After codegen, attempt to insert code into the appropriate file (MVP: append to a related file if specified) ---
  if (task.relatedFile) {
    const relatedFilePath = path.join(__dirname, '../', task.relatedFile);
    try {
      fs.appendFileSync(relatedFilePath, `\n// [AI Codegen for task: ${task.id}]\n${codegenSuggestion}\n`);
      console.log(`Codegen output appended to ${relatedFilePath}`);
    } catch (e) {
      console.log(`Warning: Could not append codegen output to ${relatedFilePath}: ${e.message}`);
    }
  }

  // --- Automate git add/commit (MVP: commit all changes with a message referencing the task) ---
  try {
    execSync('git add .', { stdio: 'inherit' });
    execSync(`git commit -m "[AI][${task.id}] ${task.purpose}"`, { stdio: 'inherit' });
    console.log('Git commit created for AI codegen changes.');
  } catch (e) {
    console.log('Warning: Could not create git commit:', e.message);
  }

  // --- Automate PR creation (MVP: if on a feature branch, push and open a PR using gh CLI) ---
  try {
    const branch = execSync('git rev-parse --abbrev-ref HEAD').toString().trim();
    if (branch !== 'main' && branch !== 'master') {
      execSync('git push', { stdio: 'inherit' });
      execSync(`gh pr create --fill --title "[AI][${task.id}] ${task.purpose}" --body "Automated PR for AI-generated code for task ${task.id}."`, { stdio: 'inherit' });
      console.log('Pull request created for AI codegen changes.');
    }
  } catch (e) {
    console.log('Warning: Could not create PR:', e.message);
  }
}

function testAndValidate() {
  // Run tests and lints
  try {
    execSync('npm run test', { stdio: 'inherit' });
    execSync('npm run lint', { stdio: 'inherit' });
    return true;
  } catch (e) {
    return false;
  }
}

function markTaskDone(task) {
  // Placeholder: In a real system, update the artifact status to done
  console.log(`Marking task as done: ${task.id}`);
  // Would call scripts/updateTask.js or similar
}

function escalateForHuman(task) {
  // Placeholder: Create a feedback artifact for human input
  console.log(`Escalating task for human input: ${task.id}`);
  // Would call newFeedbackOrRetrospective.js
}

// --- Copilot AI Agent Extension ---
// 1. Automatically update task status to 'done' in the artifact file.
// 2. Log results to a dev loop artifact for traceability.
// 3. If a task fails, auto-create a feedback artifact and link it to the failed task.
// 4. Skip tasks not assigned to 'copilot' (for multi-agent/human workflows).
// 5. After each loop, re-sync and re-index tasks to stay up-to-date.

function updateTaskStatus(task, status) {
  // Update the status of the task in its artifact file
  const taskFile = path.join(ARTIFACTS_DIR, `${task.id}.artifact`);
  if (!fs.existsSync(taskFile)) return;
  let content = fs.readFileSync(taskFile, 'utf8');
  content = content.replace(/status: .*/, `status: ${status}`);
  fs.writeFileSync(taskFile, content, 'utf8');
}

function logDevLoopResult(task, result) {
  const logFile = path.join(ARTIFACTS_DIR, 'dev_loop_log.artifact');
  const entry = `- task: ${task.id}\n  status: ${result}\n  timestamp: ${new Date().toISOString()}\n`;
  fs.appendFileSync(logFile, entry, 'utf8');
}

function createFeedbackArtifact(task, errorMsg) {
  const feedbackFile = path.join(ARTIFACTS_DIR, `feedback_${task.id}_${Date.now()}.artifact`);
  const content = `---\ntype: feedback\nrelated: ${task.id}\ndate: ${new Date().toISOString()}\n---\n\nTask failed: ${task.purpose}\nError: ${errorMsg}\n`;
  fs.writeFileSync(feedbackFile, content, 'utf8');
}

// Onboarding: auto-create a task if onboarding blockers or missing artifacts are detected
function checkOnboardingArtifacts() {
  const requiredArtifacts = [
    'artifact_index.artifact',
    'copilot_memory.artifact',
    'self_prompt_queue.json',
    'task_index.artifact'
  ];
  let blockers = [];
  for (const file of requiredArtifacts) {
    if (!fs.existsSync(path.join(ARTIFACTS_DIR, file))) {
      blockers.push(file);
    }
  }
  if (blockers.length > 0) {
    const onboardingTaskId = `task_onboarding_blockers_${Date.now()}`;
    const artifactPath = path.join(ARTIFACTS_DIR, `${onboardingTaskId}.artifact`);
    const content = `---\nid: ${onboardingTaskId}\nstatus: open\npriority: urgent\nassignee: copilot\npurpose: Onboarding blockers detected: ${blockers.join(', ')}\nrelatedFile: ''\n---\n`;
    fs.writeFileSync(artifactPath, content, 'utf8');
    console.log(`Onboarding blocker task created: ${onboardingTaskId}`);
  }
}

async function main() {
  checkOnboardingArtifacts();
  let openTasks = getOpenTasks().filter(t => t.assignee === 'copilot');
  if (openTasks.length === 0) {
    console.log('No open tasks assigned to copilot. Development loop complete.');
    return;
  }
  for (const task of openTasks) {
    await implementTask(task);
    try {
      if (testAndValidate()) {
        markTaskDone(task);
        updateTaskStatus(task, 'done');
        logDevLoopResult(task, 'done');
      } else {
        throw new Error('Test or lint failed');
      }
    } catch (e) {
      escalateForHuman(task);
      createFeedbackArtifact(task, e.message);
      logDevLoopResult(task, 'failed');
    }
  }
  // Re-sync and re-index tasks after each loop
  try {
    execSync('/Users/jono/.nvm/versions/node/v22.12.0/bin/node scripts/aiTaskManager.js sync', { stdio: 'inherit' });
    execSync('/Users/jono/.nvm/versions/node/v22.12.0/bin/node scripts/aiTaskManager.js index', { stdio: 'inherit' });
  } catch (e) {
    console.log('Warning: Could not sync or index tasks:', e.message);
  }
  console.log('Autonomous dev loop iteration complete.');
}

main();
